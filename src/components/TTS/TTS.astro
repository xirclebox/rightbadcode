---
/**
 * TextToSpeech.astro
 * An accessible text-to-speech component for blog posts.
 *
 * Usage:
 *   <TextToSpeech targetSelector="article" />
 *
 * Props:
 *   targetSelector - CSS selector for the element whose text content will be read aloud.
 *                    Defaults to "article".
 *   label          - Visible heading for the component. Defaults to "Listen to this article".
 */

 import './TTS.css';

interface Props {
  targetSelector?: string;
  label?: string;
}

const { targetSelector = "article", label = "Listen to this article" } = Astro.props;
---

<section
  class="tts-player"
  aria-label={label}
  data-target={targetSelector}
>
  <div class="tts-inner">
    <!-- ── Header ── -->
    <div class="tts-header">
      <h2 class="tts-title">{label}</h2>
      <span class="tts-separator" aria-hidden="true">&middot;</span>
      <time class="tts-duration" datetime="" aria-label="Estimated listening time"></time>
    </div>

    <!-- ── Controls ── -->
    <div class="tts-controls" role="group" aria-label="Playback controls">
      <!-- Play / Pause -->
      <button
        class="tts-btn tts-play"
        type="button"
        aria-label="Play"
        data-state="idle"
      >
        <!-- Play icon -->
        <svg class="icon-play" aria-hidden="true" width="22" height="22" viewBox="0 0 24 24" fill="currentColor">
          <polygon points="6,3 20,12 6,21"/>
        </svg>
        <!-- Pause icon -->
        <svg class="icon-pause" aria-hidden="true" width="22" height="22" viewBox="0 0 24 24" fill="currentColor">
          <rect x="5" y="3" width="4" height="18"/>
          <rect x="15" y="3" width="4" height="18"/>
        </svg>
        <!-- Replay icon -->
        <svg class="icon-replay" aria-hidden="true" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <polyline points="1 4 1 10 7 10"/>
          <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/>
        </svg>
      </button>

      <!-- Stop -->
      <button
        class="tts-btn tts-stop"
        type="button"
        aria-label="Stop"
        disabled
      >
        <svg aria-hidden="true" width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
          <rect x="4" y="4" width="16" height="16" rx="2"/>
        </svg>
      </button>

      <!-- Progress bar -->
      <div class="tts-progress-wrap" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" aria-label="Reading progress">
        <div class="tts-progress-track">
          <div class="tts-progress-fill"></div>
        </div>
        <output class="tts-time" aria-live="off">0:00</output>
      </div>

      <!-- Speed control -->
      <div class="tts-speed-group">
        <label for="tts-speed" class="tts-speed-label">Speed</label>
        <select id="tts-speed" class="tts-speed-select" aria-label="Playback speed">
          <option value="0.5">0.5×</option>
          <option value="0.75">0.75×</option>
          <option value="1" selected>1×</option>
          <option value="1.25">1.25×</option>
          <option value="1.5">1.5×</option>
          <option value="2">2×</option>
        </select>
      </div>
    </div>

    <!-- ── Live region for screen reader announcements ── -->
    <div class="tts-sr-live" aria-live="polite" aria-atomic="true"></div>

    <!-- ── Fallback message ── -->
    <noscript>
      <p class="tts-noscript">Text-to-speech requires JavaScript to be enabled.</p>
    </noscript>
    <p class="tts-unsupported" hidden>Your browser does not support text-to-speech.</p>
  </div>
</section>



<!-- ── Client-side behaviour ── -->
<script>
  class TTSPlayer {
    private root: HTMLElement;
    private playBtn: HTMLButtonElement;
    private stopBtn: HTMLButtonElement;
    private speedSelect: HTMLSelectElement;
    private progressFill: HTMLElement;
    private progressBar: HTMLElement;
    private timeOutput: HTMLOutputElement;
    private liveRegion: HTMLElement;
    private unsupported: HTMLElement;
    private durationEl: HTMLTimeElement;

    private synth: SpeechSynthesis;
    private utterance: SpeechSynthesisUtterance | null = null;
    private textContent = "";
    private state: "idle" | "playing" | "paused" | "ended" = "idle";
    private progressTimer: number | null = null;
    private startTime = 0;
    private elapsed = 0;
    private estimatedDuration = 0;
    private generation = 0; // guards against stale async callbacks

    constructor(root: HTMLElement) {
      this.root = root;
      this.synth = window.speechSynthesis;

      this.playBtn = root.querySelector(".tts-play")!;
      this.stopBtn = root.querySelector(".tts-stop")!;
      this.speedSelect = root.querySelector<HTMLSelectElement>(".tts-speed-select")!;
      this.progressFill = root.querySelector(".tts-progress-fill")!;
      this.progressBar = root.querySelector('[role="progressbar"]')!;
      this.timeOutput = root.querySelector(".tts-time")!;
      this.liveRegion = root.querySelector(".tts-sr-live")!;
      this.unsupported = root.querySelector(".tts-unsupported")!;
      this.durationEl = root.querySelector<HTMLTimeElement>(".tts-duration")!;

      this.init();
    }

    private init() {
      if (!("speechSynthesis" in window)) {
        this.unsupported.hidden = false;
        this.playBtn.disabled = true;
        return;
      }

      // Gather text from target selector
      const selector = this.root.dataset.target || "article";
      const target = document.querySelector(selector);
      if (target) {
        this.textContent = this.extractText(target);
      }

      this.updateDuration();

      this.playBtn.addEventListener("click", () => this.togglePlay());
      this.stopBtn.addEventListener("click", () => this.stop());
      this.speedSelect.addEventListener("change", () => this.onSpeedChange());
    }

    /**
     * Compute and display the estimated listening duration based on
     * word count and current playback speed.
     */
    private updateDuration() {
      const words = this.textContent.split(/\s+/).filter(Boolean).length;
      const rate = parseFloat(this.speedSelect.value);
      const totalMinutes = words / 160 / rate; // ~160 wpm at 1×

      const mins = Math.max(1, Math.round(totalMinutes));
      const isoMinutes = `PT${mins}M`;
      const label = `${mins} min`;

      this.durationEl.setAttribute("datetime", isoMinutes);
      this.durationEl.textContent = label;

      if (mins === 0) {
        this.durationEl.textContent = "< 1 min";
        this.durationEl.setAttribute("datetime", "PT1M");
      }
    }

    /**
     * Extract readable text, skipping the TTS player component itself
     * and other non-content elements.
     */
    private extractText(el: Element): string {
      const clone = el.cloneNode(true) as HTMLElement;
      // Remove the TTS component, <script>, <style>, <nav>, etc.
      clone.querySelectorAll(".tts-player, script, style, nav, aside, [aria-hidden='true']")
        .forEach((n) => n.remove());
      return (clone.textContent || "").replace(/\s+/g, " ").trim();
    }

    private togglePlay() {
      switch (this.state) {
        case "idle":
        case "ended":
          this.play();
          break;
        case "playing":
          this.pause();
          break;
        case "paused":
          this.resume();
          break;
      }
    }

    private play() {
      if (!this.textContent) {
        this.announce("No text content found to read.");
        return;
      }

      this.synth.cancel();
      this.generation++; // invalidate any pending callbacks from the old utterance
      const gen = this.generation;

      this.utterance = new SpeechSynthesisUtterance(this.textContent);
      this.utterance.rate = parseFloat(this.speedSelect.value);
      this.utterance.lang = document.documentElement.lang || "en";

      this.utterance.onend = () => {
        if (gen !== this.generation) return; // stale — ignore
        if (this.state === "playing") {
          this.setState("ended");
          this.announce("Finished reading.");
        }
      };

      this.utterance.onerror = (e) => {
        if (gen !== this.generation) return; // stale — ignore
        if (e.error !== "canceled") {
          this.setState("idle");
          this.announce("An error occurred while reading.");
        }
      };

      // Estimate duration: ~160 words per minute at 1× speed
      const wordCount = this.textContent.split(/\s+/).length;
      const rate = parseFloat(this.speedSelect.value);
      this.estimatedDuration = (wordCount / 160 / rate) * 60; // seconds
      this.elapsed = 0;
      this.startTime = performance.now();

      this.synth.speak(this.utterance);
      this.setState("playing");
      this.startProgress();
      this.announce("Reading article.");
    }

    private pause() {
      this.synth.pause();
      this.elapsed += (performance.now() - this.startTime) / 1000;
      this.stopProgress();
      this.setState("paused");
      this.announce("Paused.");
    }

    private resume() {
      this.startTime = performance.now();
      this.synth.resume();
      this.setState("playing");
      this.startProgress();
      this.announce("Resumed.");
    }

    private stop() {
      this.generation++; // invalidate pending callbacks before cancel
      this.synth.cancel();
      this.stopProgress();
      this.elapsed = 0;
      this.updateProgressUI(0);
      this.setState("idle");
      this.announce("Stopped.");
    }

    private onSpeedChange() {
      this.updateDuration();
      if (this.state === "playing" || this.state === "paused") {
        // Restart with new speed (Web Speech API doesn't support live rate changes)
        this.play();
        this.announce(`Speed set to ${this.speedSelect.value}x.`);
      }
    }

    /* ── State management ── */

    private setState(s: "idle" | "playing" | "paused" | "ended") {
      this.state = s;
      this.playBtn.dataset.state = s;

      const labels: Record<string, string> = {
        idle: "Play",
        playing: "Pause",
        paused: "Resume",
        ended: "Replay",
      };
      this.playBtn.setAttribute("aria-label", labels[s]);
      this.stopBtn.disabled = s === "idle" || s === "ended";
    }

    /* ── Progress tracking ── */

    private startProgress() {
      this.stopProgress();
      this.progressTimer = window.setInterval(() => {
        const current = this.elapsed + (performance.now() - this.startTime) / 1000;
        const pct = Math.min((current / this.estimatedDuration) * 100, 100);
        this.updateProgressUI(pct, current);
      }, 250);
    }

    private stopProgress() {
      if (this.progressTimer !== null) {
        clearInterval(this.progressTimer);
        this.progressTimer = null;
      }
    }

    private updateProgressUI(pct: number, seconds = 0) {
      this.progressFill.style.width = `${pct}%`;
      this.progressBar.setAttribute("aria-valuenow", String(Math.round(pct)));

      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      this.timeOutput.textContent = `${mins}:${String(secs).padStart(2, "0")}`;
    }

    /* ── Screen reader announcements ── */

    private announce(msg: string) {
      this.liveRegion.textContent = "";
      // Slight delay ensures the live region fires reliably
      requestAnimationFrame(() => {
        this.liveRegion.textContent = msg;
      });
    }
  }

  // Initialise every instance on the page
  document.querySelectorAll<HTMLElement>(".tts-player").forEach((el) => {
    new TTSPlayer(el);
  });
</script>